#include <omp.h>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <cmath>
#include <string>
#include <fstream>
#include <sstream>
#include <random>
#include <chrono>
#include <numbers> // for C++20 pi
#include <unistd.h>
using namespace std;
using namespace std::numbers;
/*
    Cleaner Object Oriented Approach
    Create a GravSim class that contains the bodies and the simulation parameters
    We will create one method initialize_circular which will compute the average distance from the sun and calculate the velocity
    for a circular orbit.
    We will also create a method initialize_elliptical which will compute the average distance from the sun and calculate the velocity
    for an elliptical orbit, but still only 2D with z = 0 to keep things simple. In order to be in an elliptical orbit, we need to 
    calculate the initial velocity using the vis-viva equation, which I don't know, but thankfully chatgpt does.
    GO ahead chatgpt: explain the vis-viva equation to me
    The vis-viva equation is a formula used to describe the motion of a body in a gravitational field. It relates the speed of an orbiting body to its distance from the central body.
    The equation is: v = sqrt(GM(2/r - 1/a))
    where:
    v is the speed of the orbiting body
    G is the gravitational constant
    M is the mass of the central body
    r is the distance between the orbiting body and the central body
    a is the semi-major axis of the orbit

    add_body_circular is a method that adds a body to the system used internally by initialize_circular
    add_body_elliptical is a method that adds a body to the system used internally by initialize_elliptical
    code shared by both can be put in add_body. These three methods are private to the class.

    we will load the data from a file (solarsystem.dat is generated by hand, but chatgpt augmented it to include many more bodies. Thanks chatgpt!
    Note, that I typeed Tha and chatgpt thanked itself there.

    all values of each body are stored in a struct together, there is only a single vector of body structs
    You can rearrange into separate vectors if you wish, it might be more performant. There's only one way to find out!

    compute_acceleration is a method that computes the acceleration of each body
    step_forward advances velocity and position using a simple forward Euler method
    print_system is a method that prints the state of the system
    The cleanest way to graph this would be to output a text file and call either MATLAB or python. Possibly even use a socket connection to do it
    directly but that's too much work for now.
    graph_system() is a method that graphs the system using matplotlib.
*/

const double year = 365.25*24*60*60;
const float G = 6.67e-11;
random_device rd;
mt19937 gen(0); // seed the generator with 0 for testing, this way we get the same results every time
// Kruger's rule of testing: only use real random numbers once it works
uniform_real_distribution<> dis(0, 1);

const int print_every = 100;
const int graph_every = 1000;

class GravSim {
public:
    bool verbose;
    enum class configuration {CIRCULAR, ELLIPTICAL_2D, CIRCULAR_RANDOM, ELLIPTICAL_3D}; // not doing 3D for now.
private:
    ofstream graphfile;
    vector<string> names;
    unordered_map<string, uint32_t> orbit_map;
    uint32_t find(const string& orbits) {
        auto it = orbit_map.find(orbits);
        if (it == orbit_map.end()) {
            return 0; // default to the sun
        }
        return it->second;
    }
    struct body {
        uint32_t id;    // unique identifier, let's keep strings out of the struct
        float Gm;         // precomputed G*m
        float x, y, z;    // position
        float vx, vy, vz; // velocity
        float ax, ay, az; // acceleration
        float old_ax, old_ay, old_az; // old acceleration
        void accelerate(float ax, float ay, float az) {
            this->ax += ax;
            this->ay += ay;
            this->az += az;
        }
    };
    vector<body> bodies; // everything is in a vector for easy parallelization
    float dt;
    uint64_t timestep;
    int num_steps;
    void read_line(ifstream &infile);

    void add_body(const string& name, uint32_t orbiting_body, float m, float x, float y, float z, float vx, float vy, float vz) {
        bodies.push_back({uint32_t(names.size()), G*m, x, y, z, vx, vy, vz, 0, 0, 0});
        names.push_back(name);
    }
    void add_body_circular(const string& name, uint32_t orbiting_body, float m, float a, float e, float orbPeriod);
    void add_body_circular_random(const string& name, uint32_t orbiting_body, float m, float a, float e, float orbPeriod);
    void add_body_elliptical(const string& name, uint32_t orbiting_body, float m, float a, float e, float orbPeriod);
public:
    GravSim(const char filename[], float dt, float duration, bool verbose, uint32_t print_every, uint32_t graph_every, configuration config);
    ~GravSim(); // we probably don't need a destructor, but we can just make it empty for now
    GravSim(const GravSim &orig) = delete; // let's stop people from accidentally copying the system, it can be enormous!
    GravSim& operator=(const GravSim &rhs) = delete;
    void read_line(ifstream &infile, configuration config);
    void compute_acceleration();
    void step_forward();
    void print_system() const;
    void graph_system();
};


/*
    Calculates the initial velocity for simple circular orbits around the specified body
    This method will line up all bodies initially on the x-axis which is kind of dumb.
    The next option below is circular but starts everyone at a random angle.
*/
void GravSim::add_body_circular(const string& name, uint32_t orbiting_body, float m, float a, float e, float orbPeriod) {
    float Gm = bodies[orbiting_body].Gm;
    float v0 = sqrt(Gm / a); // assuming the sun's mass for simplicity
    if (orbPeriod < 0) v0 = -v0; // reverse direction for negative orbital period
    float x = bodies[orbiting_body].x + a; // place the new body at the aphelion
    add_body(name, orbiting_body, m, x, 0, 0, 0, v0, 0);
}

/*
    Calculates the initial velocity for a circular orbit where each body starts at a random angle around the orbiting body
    We should fix this by adding a parameter to the method to specify the body being orbited.
    This method will start everyone at a random angle.
*/
void GravSim::add_body_circular_random(const string& name, uint32_t orbiting_body, float m, float a, float e, float orbPeriod) {
    float v0 = sqrt(bodies[orbiting_body].Gm / a); // assuming the sun's mass for simplicity
    if (orbPeriod < 0) v0 = -v0; // reverse direction for bodies moving in the opposite direction (example: Venus)
    float angle = dis(gen)*2*pi;
    float x = bodies[orbiting_body].x + a*cos(angle); // calculate the position of the new body with respect to the orbiting body
    float y = bodies[orbiting_body].y + a*sin(angle); // for the sun, [x,y] = [0,0] initially
    add_body(name, orbiting_body, m, x, y, 0, -v0*sin(angle), v0*cos(angle), 0);
}

/*
    Calculates the initial velocity for an elliptical orbit around the specified body
    You don't have to use this for your homework, but it's kind of cool.
*/
void GravSim::add_body_elliptical(const string& name, uint32_t orbiting_body, float m, float a, float e, float orbPeriod) {
    float Gm = bodies[orbiting_body].Gm;
    float v0 = sqrt(Gm * (1-e*e) / a); // vis-viva equation
    // O great chatgpt, we will take your word for this....

    float angle = dis(gen)*2*pi;
    add_body(name, orbiting_body, m, a*cos(angle), a*sin(angle), 0, -v0*sin(angle), v0*cos(angle), 0);
}

// read a line from the file as specified in solarsystem.dat
void GravSim::read_line(ifstream &infile, configuration config) {
    char buffer[4096];
    infile.getline(buffer, 4096);
    if (infile.fail()) return;
    if (buffer[0] == '#') return; // skip comments
    if (buffer[0] == ' '|| buffer[0] == '\0') return; // skip blank lines
    stringstream ss(buffer);
    string name, orbits;
    float mass, diam, perihelion, aphelion, orbPeriod, rotationalPeriod, axialtilt, orbinclin;
    ss >> name >> orbits >> mass >> diam >> perihelion >> aphelion >> orbPeriod >> rotationalPeriod >> axialtilt >> orbinclin;
    if (bodies.size() == 0) {
        // we need to add the sun first
        add_body(name, 0, mass, 0, 0, 0, 0, 0, 0);
        return;
    }
    uint32_t orbiting_body = find(orbits);
    if (config == configuration::CIRCULAR) {    
        add_body_circular(name, orbiting_body, mass, perihelion, 0, orbPeriod);
    } else if (config == configuration::CIRCULAR_RANDOM) {
        add_body_circular_random(name, orbiting_body, mass, perihelion, 0, orbPeriod);
    } else if (config == configuration::ELLIPTICAL_2D) {
        add_body_elliptical(name, orbiting_body, mass, perihelion, aphelion, orbPeriod);
    } else if (config == configuration::ELLIPTICAL_3D) {
       // TODO: implement elliptical 3D
    }
}

GravSim::GravSim(const char filename[], float dt, float duration, bool verbose, uint32_t print_every, uint32_t graph_every, configuration config) 
    : dt(dt), num_steps(duration/dt), verbose(verbose), timestep(0), graphfile("solargraph.dat") {

    ifstream infile(filename);
    while (infile) {
        read_line(infile, config);
    }
    infile.close();
    cout << "Starting simulation with " << bodies.size() << " bodies num_steps=" << num_steps << endl;
    for (int i = 0; i < num_steps; i++) {
        for (int j = 0; j < bodies.size(); j++) { // save the old accelerations
            bodies[j].old_ax = bodies[j].ax;
            bodies[j].old_ay = bodies[j].ay;
            bodies[j].old_az = bodies[j].az;
        }
        compute_acceleration();
        step_forward();
        if (verbose) {
            timestep = i;
//            if (i % print_every == 0) {
//                print_system();
//            }
            if (i % graph_every == 0) {
                graph_system();
                // wait for the user to press enter
//                cout << "Press enter to continue\n";
//                cin.ignore();
            }
        }
    }
}

GravSim::~GravSim() {
}

/*
    Our solver uses simple high school math

    F(m1,m2) = G*m1*m2/(d^2) 
    acceleration on m1 by m2: a(m1) = f(m1,m2)/(m1) = G*m2/(d^2)

    step forward in time: (Euler's method)
    v = v + a*dt
    x = x + v*dt

    Better: Runge-Kutta Fehlberg (RKF45)

    Compute accelerations on each body. This is the most expensive part of the simulation.
    With one core per body, we could keep acceleration in registers, but for n=10^6 that's only doable on a supercomputer.

    Use OpenMP to automatically parallelize the loop over bodies, and use SIMD to parallelize the loop over the particles
    This code will just use scalars.
    You may simplify your life by just truncating the list to a multiple of 8 bodies when you load.
    You may run this code for the base case. Your goal is to make yours much faster. Goog luck!
*/

void GravSim::compute_acceleration() {
    for (int i = 0; i < bodies.size(); i++) {
        float x1 = bodies[i].x;
        float y1 = bodies[i].y;
        float z1 = bodies[i].z;
        float ax0 = 0;
        float ay0 = 0;
        float az0 = 0;
        for (int j = 0; j < bodies.size(); j++) {
            if (i == j) continue;
            float Gm2 = bodies[j].Gm;
            float x2 = bodies[j].x;
            float y2 = bodies[j].y;
            float z2 = bodies[j].z;
            float dx = x2 - x1;
            float dy = y2 - y1;
            float dz = z2 - z1;
            // calculate r^2 not r!
            float r2 = dx*dx + dy*dy + dz*dz;
            float r = sqrt(r2);
            float a_r = Gm2/(r2*r);
            ax0 += a_r*dx;
            ay0 += a_r*dy;
            az0 += a_r*dz;
        }
        bodies[i].accelerate(ax0, ay0, az0);
    }
    print_system();
    cin.ignore();
}

// error: vx is not constant, can do a better approximation
void GravSim::step_forward() {
    for (int i = 0; i < bodies.size(); i++) {
        bodies[i].x += bodies[i].vx*dt;
        bodies[i].y += bodies[i].vy*dt;
        bodies[i].z += bodies[i].vz*dt;
        bodies[i].vx += bodies[i].ax*dt;
        bodies[i].vy += bodies[i].ay*dt;
        bodies[i].vz += bodies[i].az*dt;
    }
}

void GravSim::print_system() const {
    for (int i = 0; i < bodies.size(); i++) {
        cout << names[i] << " " << bodies[i].x << " " << bodies[i].y << " " << bodies[i].z << " " << bodies[i].vx << " " << bodies[i].vy << " " << bodies[i].vz << endl;
    }
}
#if 0
void GravSim::graph_system() const {
    static int pipefd[2];
    static pid_t pid = -1;

    if (pid == -1) { // Create the pipe and fork only once
        if (pipe(pipefd) == -1) {
            perror("pipe");
            exit(EXIT_FAILURE);
        }

        pid = fork();
        if (pid == -1) {
            perror("fork");
            exit(EXIT_FAILURE);
        }

        if (pid == 0) { // Child process
            close(pipefd[1]); // Close write end
            dup2(pipefd[0], STDIN_FILENO); // Redirect stdin to read end of pipe
            execlp("python3", "python3", "plotsolar.py", NULL);
            perror("execlp");
            exit(EXIT_FAILURE);
        } else { // Parent process
            close(pipefd[0]); // Close read end
        }
    }

    for (int i = 0; i < bodies.size(); i++) {
        dprintf(pipefd[1], "%s %f %f %f\n", names[i].c_str(), bodies[i].x, bodies[i].y, bodies[i].z);
    }
    dprintf(pipefd[1], "draw\n");
}
#endif

void GravSim::graph_system() {
    for (int i = 0; i < bodies.size(); i++) {
        graphfile << names[i] << ' ' << bodies[i].x << ' ' << bodies[i].y << ' ' << bodies[i].z << ' ';
    }
    graphfile << '\n';
}

int main(int argc, char **argv) {
    const char *filename = argc > 1 ? argv[1] : "solarsystem2.dat";
    GravSim sim(filename, 100, year, true, 10000, 100, GravSim::configuration::CIRCULAR_RANDOM);
    sim.print_system();
    sim.graph_system();
}
